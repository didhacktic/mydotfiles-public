#!/usr/bin/env bash
# linkfiles â€” Liaison fichier-par-fichier public+private (sans symlink de dossier)
# Usage: linkfiles [--dry-run] [--force] [--filter <mot>]

set -euo pipefail

PUBLIC_BASE="$HOME/didhacktic/mydotfiles-public/Arch-Hyprland"
PRIVATE_BASE="$HOME/didhacktic/mydotfiles-private/Arch-Hyprland"
TARGET_DIR="$HOME"

DRY_RUN=false
FORCE=false
FILTER=""

# Options
while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run) DRY_RUN=true; shift ;;
    --force) FORCE=true; shift ;;
    --filter) FILTER="$2"; shift 2 ;;
    -h|--help)
      cat <<EOF
Usage: $0 [--dry-run] [--force] [--filter <mot>]

Opitions:
  --dry-run      Simule les actions (ne crÃ©e aucun lien)
  --force        Si la cible existe, la sauvegarde en .bak avant remplacement
  --filter <mot> Ne traiter que les fichiers dont le chemin relatif contient <mot>
EOF
      exit 0
      ;;
    *) echo "Option inconnue: $1"; exit 1 ;;
  esac
done

log() { printf '%s\n' "$*"; }

# CrÃ©e un lien symbolique pour un fichier donnÃ© (jamais un dossier)
link_file() {
  local src="$1" dest="$2"

  # sÃ©curitÃ© : ne jamais crÃ©er de lien vers un dossier
  if [ -d "$src" ]; then
    log "   ðŸš« IgnorÃ© (dossier): $src"
    return
  fi

  if [ -e "$dest" ] || [ -L "$dest" ]; then
    # existe dÃ©jÃ  : si c'est dÃ©jÃ  le bon lien, on skip
    if [ -L "$dest" ] && [ "$(readlink -f "$dest")" = "$(readlink -f "$src")" ]; then
      log "   -> cible dÃ©jÃ  correcte : $dest"
      return
    fi

    # ne jamais remplacer un dossier par un lien symbolique
    if [ -d "$dest" ] && [ ! -L "$dest" ]; then
      log "   âš ï¸  Cible est un dossier rÃ©el â€” ignorÃ© : $dest"
      return
    fi

    if [ "$FORCE" = true ]; then
      local bak="${dest}.bak.$(date +%s)"
      if [ "$DRY_RUN" = true ]; then
        log "   ðŸ§ª Simulation : mv \"$dest\" \"$bak\""
      else
        mkdir -p "$(dirname "$bak")"
        mv "$dest" "$bak"
        log "   âš ï¸  SauvegardÃ© $dest -> $bak"
      fi
    else
      log "   âš ï¸  Cible existe (utiliser --force pour sauvegarder) : $dest"
      return
    fi
  fi

  # crÃ©e le dossier parent et le lien symbolique
  if [ "$DRY_RUN" = true ]; then
    log "   ðŸ§ª Simulation : mkdir -p \"$(dirname "$dest")\""
    log "   ðŸ§ª Simulation : ln -s \"$src\" \"$dest\""
  else
    mkdir -p "$(dirname "$dest")"
    ln -s "$src" "$dest"
    log "   âœ… Lien crÃ©Ã© : $dest -> $src"
  fi
}

# Parcours rÃ©cursif d'une base
process_base() {
  local base="$1" label="$2"
  if [ ! -d "$base" ]; then
    log "â„¹ï¸  [$label] non trouvÃ© : $base â€” saut."
    return
  fi

  log "ðŸ” [$label] Parcours de : $base"
  while IFS= read -r -d $'\0' file; do
    rel="${file#$base/}"
    if [ -n "$FILTER" ] && [[ "$rel" != *"$FILTER"* ]]; then
      continue
    fi
    dest="$TARGET_DIR/$rel"
    log "-> [$label] $rel"
    link_file "$file" "$dest"
  done < <(find "$base" -type f -print0 | sort -z)
  echo
}

# ordre : public puis private (private Ã©crase)
process_base "$PUBLIC_BASE" "public"
process_base "$PRIVATE_BASE" "private"

if [ "$DRY_RUN" = true ]; then
  log "âœ… Simulation terminÃ©e."
else
  log "ðŸŽ‰ OpÃ©rations terminÃ©es."
fi
